<!doctype article PUBLIC "-//OASIS//DTD DocBook V3.1//EN">
<article>
<artheader>
	<author>Martin Lazar &lt;mlazar@suse.cz&gt;</author>
</artheader>

<title id="AFT-top">pluglib-bindings documentation</title>
<author>Martin Lazar &lt;mlazar@suse.cz&gt;</author>
<para>
This package allow use C/C++ LiMaL library in YCP. It use SWIG for
generate Perl wrapper and XML representation of C/C++ header file. YCP
type information (TYPEINFO) is then generated from the XML file.
</para>



<para>
SWIG is tool to generate scripting interface to C/C++ code. SWIG
typemaps describe how to convert data types from C/C++ to script
language. Interface file (<computeroutput>.i</computeroutput> extension) describe data types and input
and output arguments of functions. It also contains typemaps. Description
of types and functions use the same syntax as C/C++ header file. So you
can use real header file and just include typemaps. Pluglib-bindings
offers two sets of typemaps: <computeroutput>LiMaL.i</computeroutput> and <computeroutput>BloCxx.i</computeroutput>. The first is for
libraries using only STL. The second is for libraries using BloCxx.
</para>
</sec2>

<variablelist>
<varlistentry><term>Basic C data types</term><listitem></listitem>
<itemizedlist mark=opencircle>
<listitem> (<computeroutput>un</computeroutput>)<computeroutput>signed</computeroutput> <computeroutput>char</computeroutput>/<computeroutput>short</computeroutput>/<computeroutput>int</computeroutput>/<computeroutput>long</computeroutput>/<computeroutput>long long</computeroutput></listitem>
<listitem> <computeroutput>float</computeroutput></listitem>
<listitem> <computeroutput>double</computeroutput></listitem>
</itemizedlist>
</variablelist>
<variablelist>
<varlistentry><term>STL data types</term><listitem></listitem>
<itemizedlist mark=opencircle>
<listitem> <computeroutput>std::string</computeroutput></listitem>
<listitem> <computeroutput>std::list</computeroutput> (one and two level only)</listitem>
<listitem> <computeroutput>std::deque</computeroutput> (one and two level only)</listitem>
<listitem> <computeroutput>std::map</computeroutput> (one level only)</listitem>
</itemizedlist>
</variablelist>
<variablelist>
<varlistentry><term>BloCxx types</term><listitem></listitem>
<itemizedlist mark=opencircle>
<listitem> (<computeroutput>U</computeroutput>)<computeroutput>Int8</computeroutput>/<computeroutput>16</computeroutput>/<computeroutput>32</computeroutput>/<computeroutput>64</computeroutput></listitem>
<listitem> <computeroutput>Real32</computeroutput>, <computeroutput>Real64</computeroutput></listitem>
<listitem> <computeroutput>Bool</computeroutput></listitem>
<listitem> <computeroutput>String</computeroutput></listitem>
<listitem> <computeroutput>List</computeroutput> (one and two level only)</listitem>
<listitem> <computeroutput>Map</computeroutput> (one level only)</listitem>
</itemizedlist>
</variablelist>
<para>
Also pointers and references to this data types are supported.
</para>
</sec2>

<para>
For each family of data types (<computeroutput>stdc</computeroutput>, <computeroutput>stl</computeroutput> and <computeroutput>blocxx</computeroutput>) exist
individual directory contains file <computeroutput>types.i</computeroutput> which is included from main
interface file (<computeroutput>LiMaL.i</computeroutput> or <computeroutput>BloCxx.i</computeroutput>). This file defines typemaps for
corresponding elementary data types (e.g.: strings). For compound data
types using C++ templates (lists, hashes) we used modular system of
macros.
</para>


<para>
Problem with C++ templates is that compiler need to know concrete data
type in compilation time. Swig have to generate wrappers for all used
data types. To achieve this swig have to have defined typemaps for all
possible types. All typemaps definition for STL-like sequences
(<computeroutput>std::deque&lt;*&gt;</computeroutput>, <computeroutput>std::list&lt;*&gt;</computeroutput>, <computeroutput>BloCxx::List&lt;*&gt;</computeroutput>, ...) are the same,
except for conversion of elementary types.
</para>
<para>
File <computeroutput>generic/sequence.i</computeroutput> contains generic sequence typemaps for onle
and two level sequences (eg.: <computeroutput>std::list&lt;std::list&lt;int&gt;&gt;</computeroutput>). It has to be
specialised for concrete types. Indeed, it is a macro, which define real
typemaps. Usage:
</para>
<literallayout>
specialize_generic_sequence(L, T, FROM_SV, TO_SV, CHECK_SV)
</literallayout>
<para>
where <emphasis role=bold>L</emphasis> is STL-like sequence (eg. <computeroutput>std::deque</computeroutput>, <computeroutput>std::list</computeroutput>, ...), <emphasis role=bold>T</emphasis>
is elementary type (eg. <computeroutput>int</computeroutput>, <computeroutput>std::string</computeroutput>, ...), <emphasis role=bold>FROM_SV</emphasis> and
<emphasis role=bold>TO_SV</emphasis> are functions for convert elementary type from perl SV and to
perl SV. See details in next chapter. <emphasis role=bold>CHECK_SV</emphasis> is function for check
if SV is given type. It is intended for supporting overloaded C++
functions. In current version it is not implemented. For now use dummy
check function called <computeroutput>CHECK</computeroutput>.
</para>
<para>
In <computeroutput>stl/sequence.i</computeroutput> is macros specializing generic sequence:
<computeroutput>specialize_stl_sequence(T, FROM<emphasis role=bold>SV, TO</emphasis>SV, CHECK_SV)</computeroutput>. It specialize
generic sequence with <computeroutput>std::list</computeroutput>, <computeroutput>std::deque</computeroutput>, <computeroutput>std::vector</computeroutput> and
<computeroutput>std::slist</computeroutput>. However, elementary data types have to be specialized.
Similarly, <computeroutput>blocxx/sequence.i</computeroutput> contains macro
<computeroutput>specialize_blocxx_sequence</computeroutput> which specialize generic sequence with
<computeroutput>BloCxx::List</computeroutput>.
</para>
<para>
Finaly, in <computeroutput>LiMal.i</computeroutput> is defined macro
</para>
<literallayout>
specialize_sequence(T, FROM_SV, TO_SV, CHECK_SV)
</literallayout>
<para>
which call <computeroutput>specialize_stl_sequencce</computeroutput>. Similarly, in <computeroutput>BloCxx.i</computeroutput> this
macro call <computeroutput>specialize_blocxx_sequence</computeroutput>. So, in your interface file, you
can define all sequnce typemas with given elementary data type by
calling macro <computeroutput>specialize_sequence</computeroutput> regardless of which compoud types
you use (STL or BloCxx).  Common C++ and STL/BloCxx data types are
already specialized, so you have to specialize only user defined types
(eg. list of structures).
</para>
</sec3>

<para>
For compound data type typemaps we will need elementary data converters
from/to perl scalar:
</para>
<literallayout>
bool FROM_SV(SV *sv, T *data, int size, const swig_type_info *t);
bool TO_SV(SV *sv, T *data, int size, const swig_type_info *t);
</literallayout>
<para>
They return <emphasis role=bold>true</emphasis> on succes and <emphasis role=bold>false</emphasis> on fail. <emphasis role=bold>sv</emphasis> is perl scalar
from/to should be converted, <emphasis role=bold>data</emphasis> is source/target of conversion,
<emphasis role=bold>size</emphasis> is simply <computeroutput>sizeof(T)</computeroutput> and <emphasis role=bold>t</emphasis> is pointer to swig type descriptor
table.
</para>
<para>
In <computeroutput>stdc/types.i</computeroutput> are converter functions for all standart elementray
C++ data types. They are called: <computeroutput>FROM_BOLL</computeroutput>, <computeroutput>FROM_CHAR</computeroutput>,
<computeroutput>FROM_SHORT</computeroutput>, <computeroutput>FROM_INT</computeroutput>, <computeroutput>FROM_LONG</computeroutput>, <computeroutput>FROM_QUAD</computeroutput>, <computeroutput>FROM_UCHAR</computeroutput>,
<computeroutput>FROM_USHORT</computeroutput>, <computeroutput>FROM_UINT</computeroutput>, <computeroutput>FROM_ULONG</computeroutput>, <computeroutput>FROM_UQUAD</computeroutput>,
<computeroutput>FROM_DOUBLE</computeroutput>, <computeroutput>FROM_FLOAT</computeroutput>, <computeroutput>TO_BOLL</computeroutput>, <computeroutput>TO_CHAR</computeroutput>, <computeroutput>TO_SHORT</computeroutput>,
<computeroutput>TO_INT</computeroutput>, <computeroutput>TO_LONG</computeroutput>, <computeroutput>TO_QUAD</computeroutput>, <computeroutput>TO_UCHAR</computeroutput>, <computeroutput>TO_USHORT</computeroutput>,
<computeroutput>TO_UINT</computeroutput>, <computeroutput>TO_ULONG</computeroutput>, <computeroutput>TO_UQUAD</computeroutput>, <computeroutput>TO_DOUBLE</computeroutput>, and <computeroutput>TO_FLOAT</computeroutput>.
There are also functions called <computeroutput>FROM_PACK</computeroutput> and <computeroutput>TO_PACK</computeroutput> which store
piece of memory as perl string of hex digits (eg. for structures).
</para>
<para>
In <computeroutput>stl/string.i</computeroutput> they are converter functions fot STL strings:
<computeroutput>FROM_STL_STRING</computeroutput> and <computeroutput>TO_STL_STRIN</computeroutput>. Similarly in <computeroutput>blocxx/string.i</computeroutput>
are converter function for BloCxx string: <computeroutput>FROM_BLOCXX_STRING</computeroutput> and
<computeroutput>TO_BLOCXX_STRING</computeroutput>.
</para>
</sec3>

<para>
Similirly as generic sequence, file <computeroutput>generis/hash.i</computeroutput> contains generic
hashes typemaps. Only elementary data types are defined here -- no
nested compund types. There are three things, we have to specialize:
hash type, key type nad value type. File <computeroutput>generic/hash_list.i</computeroutput> contains
generic typemaps for list of hashes and hash of lists. Now, there are
four things to specialize: hash type, list type, key type, and value
type.
</para>
<para>
In <computeroutput>stl/hash.i</computeroutput> is macro called <computeroutput>specialize_stl_hash</computeroutput> which specialize
generic hash with <computeroutput>std::map</computeroutput> and generic hash of lists and list of hash
with <computeroutput>std::map</computeroutput> (hash) and <computeroutput>std::list</computeroutput>, <computeroutput>std::deque</computeroutput>, <computeroutput>std::vector</computeroutput>, and
<computeroutput>std::slist</computeroutput> (list). You have to specialize only key type and value
type. Similary, in <computeroutput>blocxx/hash.i</computeroutput> is macro <computeroutput>specialize_blocxx_hash</computeroutput>
which specialize generic hashes with <computeroutput>BloCxx::Map</computeroutput> (hash) and
<computeroutput>BloCxx::List</computeroutput> (list). There also exists macro
</para>
<literallayout>
specialize_hash(KEY, KEY_FROM_SV, KEY_TO_SV, KEY_CHECK_SV, VAL,VAL_FROM_SV, VAL_TO_SV, VAL_CHECK_SV)
</literallayout>
<para>
which specialize hash typemaps regradless of which compoud types you use
(STL or BloCxx).  Common C++ and STL/BloCxx data types are already
specialized, so you have to specialize only user defined types (eg. hash
of structures).
</para>
</sec3>

</sec2>


</article>

