<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>pluglib-bindings documentation</title>
	<meta name="author" content="Martin Lazar &lt;mlazar@suse.cz&gt;">
	<meta name="GENERATOR" content = "Almost Free Text v5.095; Copyright 1996-2004 Todd Coram. All rights reserved.">
<style type="text/css">
  <!--
html { background: #eee; color: #000; }

body { background: #eee; color: #000; margin: 0; padding: 0;}

div.body {
	background: #fff; color: #000;
	margin: 0 1em 0 1em; padding: 1em;
	font-family: serif;
	font-size: 1em; line-height: 1.2em;
	border-width: 0 1px 0 1px;
	border-style: solid;
	border-color: #aaa;
}

div.block {
	background: #F8F8FF; color: #000;
	margin: 1em; padding: 0 1em 0 1em;
	border-width: 1px;
	border-style: solid;
	border-color: #909090;
}

table {
	background: #F8F8F8; color: #000;
	margin: 1em;
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #C0C0C0;
}

td {
	border-width: 0 1px 1px 0;
	border-style: solid;
	border-color: #C0C0C0;
}

th {
	background: #F8F8FF;
	border-width: 1px 1px 2px 0;
	border-style: solid;
	border-color: #C0C0C0;
}


/* body text, headings, and rules */

p { margin: 0; text-indent: 0em; margin: 0 0 0.5em 0 }

h1, h2, h3, h4, h5, h6 {
	color: #206020; background: transparent;
	font-family: Optima, Arial, Helvetica, sans-serif;
	font-weight: normal;
}

h1 { font-size: 1.69em; margin: 1.4em 0 0.4em 0; }
h2 { font-size: 1.44em; margin: 1.4em 0 0.4em 0; }
h3 { font-size: 1.21em; margin: 1.4em 0 0.4em 0; }
h4 { font-size: 1.00em; margin: 1.4em 0 0.4em 0; }
h5 { font-size: 0.81em; margin: 1.4em 0 0.4em 0; }
h6 { font-size: 0.64em; margin: 1.4em 0 0.4em 0; }

hr {
	color: transparent; background: transparent;
	height: 0px; margin: 0.6em 0;
	border-width: 1px ;
	border-style: solid;
	border-color: #999;
}

/* bulleted lists and definition lists */

ul { margin: 0 1em 0.6em 2em; padding: 0; }
li { margin: 0.4em 0 0 0; }

dl { margin: 0.6em 1em 0.6em 2em; }
dt { color: #206020; }

tt { color: #602020; }

/* links */

a.link {
	color: #33c; background: transparent;
	text-decoration: none;
}

a:hover {
	color: #000; background: transparent;
}

body > a {
	font-family: Optima, Arial, Helvetica, sans-serif;
	font-size: 0.81em;
}

h1, h2, h3, h4, h5, h6 {
	color: #206020; background: transparent;
	font-family: Optima, Arial, Helvetica, sans-serif;
	font-weight: normal;
}

  -->
</style>
</head>
<body>
<div class="body">

<br><center><h1><a name="AFT-top">pluglib-bindings documentation</a></h1></center>
<br><center><h2>Martin Lazar &lt;mlazar@suse.cz&gt;</h2></center>
<p class="Body">
This package allow use C/C++ LiMaL library in YCP. It use SWIG for
generate Perl wrapper and XML representation of C/C++ header file. YCP
type information (TYPEINFO) is then generated from the XML file.
</p>
<!-- Start SectLevel1 -->
<!-- Start SectLevel2 -->
<h3><a name="SWIG interface and typemaps">SWIG interface and typemaps</a></h3>
<p class="Body">
SWIG is tool to generate scripting interface to C/C++ code. SWIG
typemaps describe how to convert data types from C/C++ to script
language. Interface file (<tt>.i</tt> extension) describe data types and input
and output arguments of functions. It also contains typemaps. Description
of types and functions use the same syntax as C/C++ header file. So you
can use real header file and just include typemaps. Pluglib-bindings
offers two sets of typemaps: <tt>LiMaL.i</tt> and <tt>BloCxx.i</tt>. The first is for
libraries using only STL. The second is for libraries using BloCxx.
</p>
<!--End Section 2-->
<h3><a name="Supported data types">Supported data types</a></h3>
<dl>
<dt><strong>Basic C data types</strong></dt><dd></li>
<ul>
<li> (<tt>un</tt>)<tt>signed</tt> <tt>char</tt>/<tt>short</tt>/<tt>int</tt>/<tt>long</tt>/<tt>long long</tt></li>
<li> <tt>float</tt></li>
<li> <tt>double</tt></li>
</ul>
</dl>
<dl>
<dt><strong>STL data types</strong></dt><dd></li>
<ul>
<li> <tt>std::string</tt></li>
<li> <tt>std::list</tt> (one and two level only)</li>
<li> <tt>std::deque</tt> (one and two level only)</li>
<li> <tt>std::map</tt> (one level only)</li>
</ul>
</dl>
<dl>
<dt><strong>BloCxx types</strong></dt><dd></li>
<ul>
<li> (<tt>U</tt>)<tt>Int8</tt>/<tt>16</tt>/<tt>32</tt>/<tt>64</tt></li>
<li> <tt>Real32</tt>, <tt>Real64</tt></li>
<li> <tt>Bool</tt></li>
<li> <tt>String</tt></li>
<li> <tt>List</tt> (one and two level only)</li>
<li> <tt>Map</tt> (one level only)</li>
</ul>
</dl>
<p class="Body">
Also pointers and references to this data types are supported.
</p>
<!--End Section 2-->
<h3><a name="Pluglib-bindings typemaps internal">Pluglib-bindings typemaps internal</a></h3>
<p class="Body">
For each family of data types (<tt>stdc</tt>, <tt>stl</tt> and <tt>blocxx</tt>) exist
individual directory contains file <tt>types.i</tt> which is included from main
interface file (<tt>LiMaL.i</tt> or <tt>BloCxx.i</tt>). This file defines typemaps for
corresponding elementary data types (e.g.: strings). For compound data
types using C++ templates (lists, hashes) we used modular system of
macros.
</p>
<!-- Start SectLevel3 -->
<h4><a name="Sequence typemaps">Sequence typemaps</a></h4>
<p class="Body">
Problem with C++ templates is that compiler need to know concrete data
type in compilation time. Swig have to generate wrappers for all used
data types. To achieve this swig have to have defined typemaps for all
possible types. All typemaps definition for STL-like sequences
(<tt>std::deque&lt;*&gt;</tt>, <tt>std::list&lt;*&gt;</tt>, <tt>BloCxx::List&lt;*&gt;</tt>, ...) are the same,
except for conversion of elementary types.
</p>
<p class="Body">
File <tt>generic/sequence.i</tt> contains generic sequence typemaps for onle
and two level sequences (eg.: <tt>std::list&lt;std::list&lt;int&gt;&gt;</tt>). It has to be
specialised for concrete types. Indeed, it is a macro, which define real
typemaps. Usage:
</p>
<div class="block"><pre>
specialize_generic_sequence(L, T, FROM_SV, TO_SV, CHECK_SV)
</pre></div>
<p class="Body">
where <strong>L</strong> is STL-like sequence (eg. <tt>std::deque</tt>, <tt>std::list</tt>, ...), <strong>T</strong>
is elementary type (eg. <tt>int</tt>, <tt>std::string</tt>, ...), <strong>FROM_SV</strong> and
<strong>TO_SV</strong> are functions for convert elementary type from perl SV and to
perl SV. See details in next chapter. <strong>CHECK_SV</strong> is function for check
if SV is given type. It is intended for supporting overloaded C++
functions. In current version it is not implemented. For now use dummy
check function called <tt>CHECK</tt>.
</p>
<p class="Body">
In <tt>stl/sequence.i</tt> is macros specializing generic sequence:
<tt>specialize_stl_sequence(T, FROM<strong>SV, TO</strong>SV, CHECK_SV)</tt>. It specialize
generic sequence with <tt>std::list</tt>, <tt>std::deque</tt>, <tt>std::vector</tt> and
<tt>std::slist</tt>. However, elementary data types have to be specialized.
Similarly, <tt>blocxx/sequence.i</tt> contains macro
<tt>specialize_blocxx_sequence</tt> which specialize generic sequence with
<tt>BloCxx::List</tt>.
</p>
<p class="Body">
Finaly, in <tt>LiMal.i</tt> is defined macro
</p>
<div class="block"><pre>
specialize_sequence(T, FROM_SV, TO_SV, CHECK_SV)
</pre></div>
<p class="Body">
which call <tt>specialize_stl_sequencce</tt>. Similarly, in <tt>BloCxx.i</tt> this
macro call <tt>specialize_blocxx_sequence</tt>. So, in your interface file, you
can define all sequnce typemas with given elementary data type by
calling macro <tt>specialize_sequence</tt> regardless of which compoud types
you use (STL or BloCxx).  Common C++ and STL/BloCxx data types are
already specialized, so you have to specialize only user defined types
(eg. list of structures).
</p>
<!--End Section 3-->
<h4><a name="Elementary data converters">Elementary data converters</a></h4>
<p class="Body">
For compound data type typemaps we will need elementary data converters
from/to perl scalar:
</p>
<div class="block"><pre>
bool FROM_SV(SV *sv, T *data, int size, const swig_type_info *t);
bool TO_SV(SV *sv, T *data, int size, const swig_type_info *t);
</pre></div>
<p class="Body">
They return <strong>true</strong> on succes and <strong>false</strong> on fail. <strong>sv</strong> is perl scalar
from/to should be converted, <strong>data</strong> is source/target of conversion,
<strong>size</strong> is simply <tt>sizeof(T)</tt> and <strong>t</strong> is pointer to swig type descriptor
table.
</p>
<p class="Body">
In <tt>stdc/types.i</tt> are converter functions for all standart elementray
C++ data types. They are called: <tt>FROM_BOLL</tt>, <tt>FROM_CHAR</tt>,
<tt>FROM_SHORT</tt>, <tt>FROM_INT</tt>, <tt>FROM_LONG</tt>, <tt>FROM_QUAD</tt>, <tt>FROM_UCHAR</tt>,
<tt>FROM_USHORT</tt>, <tt>FROM_UINT</tt>, <tt>FROM_ULONG</tt>, <tt>FROM_UQUAD</tt>,
<tt>FROM_DOUBLE</tt>, <tt>FROM_FLOAT</tt>, <tt>TO_BOLL</tt>, <tt>TO_CHAR</tt>, <tt>TO_SHORT</tt>,
<tt>TO_INT</tt>, <tt>TO_LONG</tt>, <tt>TO_QUAD</tt>, <tt>TO_UCHAR</tt>, <tt>TO_USHORT</tt>,
<tt>TO_UINT</tt>, <tt>TO_ULONG</tt>, <tt>TO_UQUAD</tt>, <tt>TO_DOUBLE</tt>, and <tt>TO_FLOAT</tt>.
There are also functions called <tt>FROM_PACK</tt> and <tt>TO_PACK</tt> which store
piece of memory as perl string of hex digits (eg. for structures).
</p>
<p class="Body">
In <tt>stl/string.i</tt> they are converter functions fot STL strings:
<tt>FROM_STL_STRING</tt> and <tt>TO_STL_STRIN</tt>. Similarly in <tt>blocxx/string.i</tt>
are converter function for BloCxx string: <tt>FROM_BLOCXX_STRING</tt> and
<tt>TO_BLOCXX_STRING</tt>.
</p>
<!--End Section 3-->
<h4><a name="Hashes typemaps">Hashes typemaps</a></h4>
<p class="Body">
Similirly as generic sequence, file <tt>generis/hash.i</tt> contains generic
hashes typemaps. Only elementary data types are defined here -- no
nested compund types. There are three things, we have to specialize:
hash type, key type nad value type. File <tt>generic/hash_list.i</tt> contains
generic typemaps for list of hashes and hash of lists. Now, there are
four things to specialize: hash type, list type, key type, and value
type.
</p>
<p class="Body">
In <tt>stl/hash.i</tt> is macro called <tt>specialize_stl_hash</tt> which specialize
generic hash with <tt>std::map</tt> and generic hash of lists and list of hash
with <tt>std::map</tt> (hash) and <tt>std::list</tt>, <tt>std::deque</tt>, <tt>std::vector</tt>, and
<tt>std::slist</tt> (list). You have to specialize only key type and value
type. Similary, in <tt>blocxx/hash.i</tt> is macro <tt>specialize_blocxx_hash</tt>
which specialize generic hashes with <tt>BloCxx::Map</tt> (hash) and
<tt>BloCxx::List</tt> (list). There also exists macro
</p>
<div class="block"><pre>
specialize_hash(KEY, KEY_FROM_SV, KEY_TO_SV, KEY_CHECK_SV, VAL,VAL_FROM_SV, VAL_TO_SV, VAL_CHECK_SV)
</pre></div>
<p class="Body">
which specialize hash typemaps regradless of which compoud types you use
(STL or BloCxx).  Common C++ and STL/BloCxx data types are already
specialized, so you have to specialize only user defined types (eg. hash
of structures).
</p>
<!--End Section 3-->
<!-- End SectLevel3 -->
<!--End Section 2-->
<!-- End SectLevel2 -->
<!-- End SectLevel1 -->
<hr>
<br>
<p align="right"> <small>This document was generated using <a class="link" href="http://www.maplefish.com/todd/aft.html">AFT v5.095</a></small> </p>
</body>
</html>

